<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>存储布局 - The Embedonomicon</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="smallest-no-std.html"><strong aria-hidden="true">1.</strong> 最简的 #![no_std] 程序</a></li><li class="chapter-item expanded "><a href="memory-layout.html" class="active"><strong aria-hidden="true">2.</strong> 存储布局</a></li><li class="chapter-item expanded "><a href="main.html"><strong aria-hidden="true">3.</strong> 一个 main 接口</a></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">4.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="asm.html"><strong aria-hidden="true">5.</strong> 稳定的汇编</a></li><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">6.</strong> 使用符号做日志</a></li><li class="chapter-item expanded "><a href="singleton.html"><strong aria-hidden="true">7.</strong> 全局单例</a></li><li class="chapter-item expanded "><a href="dma.html"><strong aria-hidden="true">8.</strong> DMA</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="compiler-support.html">与编译器支持有关的笔记</a></li><li class="chapter-item expanded affix "><a href="custom-target.html">制造一个自定义目标</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="存储布局"><a class="header" href="#存储布局">存储布局</a></h1>
<p>下一步是确保程序有正确的存储布局，目标平台才可以执行它。在我们的例子里，将使用一个虚拟的Cortex-M3微控制器：<a href="http://www.ti.com/product/LM3S6965">LM3S6965</a> 。我们的程序是运行在设备上的唯一一个进程，因此它必须要负责初始化设备。</p>
<h2 id="背景信息"><a class="header" href="#背景信息">背景信息</a></h2>
<p>Cortex-M 设备需要把<a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/exception-model/vector-table">向量表</a>放在<a href="https://developer.arm.com/docs/dui0552/latest/the-cortex-m3-processor/memory-model">代码区</a>的开始处。
向量表是一组指针；启动设备需要前两个指针，剩下来的指针都与异常有关。我们现在忽略它们。</p>
<p>链接器决定程序的最终存储布局，但是我们可以用<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">链接器脚本</a>对它进行一些控制。链接器提供的控制布局的精细度在<em>sections</em>层级。一个section是存储在连续的内存地址中的<em>符号</em>的集合。符号，依次，可以是数据(一个静态变量)，或者指令(一个Rust函数)。</p>
<p>每一个符号有一个由编译器分配的名字。自Rust 1.28以来，Rust编译器分配给符号的名字都是这样的格式:
<code>_ZN5krate6module8function17he1dfc17c86fe16daE</code>，其展开是 <code>krate::module::function::he1dfc17c86fe16da</code> 其中 <code>krate::module::function</code> 是函数或者变量的路径，<code>he1dfc17c86fe16da</code> 是某个哈希值。Rust编译器将把每个符号放进它自己的独有的section中；比如之前提到的符号将被放进一个名为 <code>.text._ZN5krate6module8function17he1dfc17c86fe16daE</code> 的section中。</p>
<p>这些编译器产生的符号和section名在不同的Rust编译器发布版中不保证是不变的。然而，语言让我们可以使用这些attributes控制符号名和放置的section:</p>
<ul>
<li><code>#[export_name = &quot;foo&quot;]</code> 把符号名设置成 <code>foo</code> 。</li>
<li><code>#[no_mangle]</code> 意思是: 使用函数或者变量名(不是它的全路径)作为它的符号名。
<code>#[no_mangle] fn bar()</code> 将产生一个名为 <code>bar</code> 的符号。</li>
<li><code>#[link_section = &quot;.bar&quot;]</code> 把符号放进一个名为 <code>.bar</code> 的section中。</li>
</ul>
<p>有了这些attributes，我们可以稳定一个程序的ABI，并在链接器脚本中使用它。</p>
<h2 id="rust-部分"><a class="header" href="#rust-部分">Rust 部分</a></h2>
<p>像上面提到的，对于Cortex-M设备，我们需要修改向量表的前两项。第一个，栈指针的初始值，只能使用链接器脚本修改。第二个，重置向量，需要在Rust代码中生成并使用链接器脚本放置到正确的地方。</p>
<p>重置向量是一个指向重置处理函数的指针。重置处理函数是在一个系统重启后，或者第一次上电后，设备将会执行的函数。重置处理函数总是硬件调用栈中的第一个栈帧；从它返回是未定义的行为，因为没有其它栈帧可以给它返回。通过让它变成一个divergent function，我们可以强调这个重置处理函数从来不会返回，divergent function的签名是 <code>fn(/* .. */) -&gt; !</code> 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    let _x = 42;

    // can't return so we go into an infinite loop here
    loop {}
}

// The reset vector, a pointer into the reset handler
#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern &quot;C&quot; fn() -&gt; ! = Reset;

<span class="boring">}</span></code></pre></pre>
<p>我们通过使用 <code>extern &quot;C&quot;</code> 告诉编译器下面的函数使用C的ABI，而不是Rust的ABI，后者不稳定，将函数变成硬件期望的格式。</p>
<p>为了从链接器脚本中指出重置处理函数和重置向量，我们需要它们有一个稳定的符号名因此我们使用 <code>#[no_mangle]</code> 。我们需要稍微控制下 <code>RESET_VECTOR</code> 的位置，因此我们将它放进一个已知的section中，<code>.vector_table.reset_vector</code> 。重置处理函数，<code>Reset</code> ，的确切位置不重要。我们只使用编译器默认生成的section 。</p>
<p>当遍历输入目标文件的列表时，这个链接器将忽略是内部链接的符号(也叫内部符号)，因此我们需要让我们的符号变成外部链接。在Rust中让一个符号变成外部的方法，只有使它的相关项变成公共的(<code>pub</code>)和<em>可到达的</em>(在项和crate的根路径间没有私有模块)。</p>
<h2 id="链接器脚本部分"><a class="header" href="#链接器脚本部分">链接器脚本部分</a></h2>
<p>一个最小的，将向量表放进正确的位置的链接器脚本如下所示。让我们仔细看看。</p>
<pre><code class="language-console">$ cat link.x
</code></pre>
<pre><code class="language-text">/* Memory layout of the LM3S6965 microcontroller */
/* 1K = 1 KiBi = 1024 bytes */
MEMORY
{
  FLASH : ORIGIN = 0x00000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 64K
}

/* The entry point is the reset handler */
ENTRY(Reset);

EXTERN(RESET_VECTOR);

SECTIONS
{
  .vector_table ORIGIN(FLASH) :
  {
    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));

    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));
  } &gt; FLASH

  .text :
  {
    *(.text .text.*);
  } &gt; FLASH

  /DISCARD/ :
  {
    *(.ARM.exidx .ARM.exidx.*);
  }
}
</code></pre>
<h3 id="memory"><a class="header" href="#memory"><code>MEMORY</code></a></h3>
<p>链接器脚本的这个部分描述了目标中存储区块的大小和位置。有两个存储区块被定义了: <code>FLASH</code> 和 <code>RAM</code> ；它们都与目标中可用的物理存储有关。这里用的值与LM3S6965微控制器有关。</p>
<h3 id="entry"><a class="header" href="#entry"><code>ENTRY</code></a></h3>
<p>这里我们指给链接器，符号名为 <code>Reset</code> 的重置处理函数是程序的 <em>entry point</em> 。链接器会主动丢弃未使用的部分。链接器认为entry point和从它处被调用的函数是<em>被使用了的</em>，所以链接器将不会丢弃它们。没有这一行，链接器将会丢弃 <code>Reset</code> 函数和所有它接下来会调用的函数。</p>
<h3 id="extern"><a class="header" href="#extern"><code>EXTERN</code></a></h3>
<p>链接器是懒惰的；一旦它们找到了从entry point处递归引用的所有的符号，它们将停止查看输入目标文件。<code>EXTERN</code> 强迫链接器去寻找 <code>EXTERN</code> 的参数，即使其它所有的被引用的符号都被找到后。因为thumb的一个规则，如果你想要一个符号，其没有被entry point调用，总是出现在输出的二进制项中，你应该使用结合了 <code>KEEP</code> 的 <code>EXTERN</code> 。</p>
<h3 id="sections"><a class="header" href="#sections"><code>SECTIONS</code></a></h3>
<p>这部分描述了输入目标文件中的sections(也被称为<em>input sections</em>)要如何被安排进输出目标文件的sections(也被称为output sections)中的或者它们是否应该被丢弃。这里，我们定义两个输出sections:</p>
<pre><code class="language-text">  .vector_table ORIGIN(FLASH) : { /* .. */ } &gt; FLASH
</code></pre>
<p><code>.vector_table</code> 包含向量表且坐落于 <code>FLASH</code> 存储的开始处。</p>
<pre><code class="language-text">  .text : { /* .. */ } &gt; FLASH
</code></pre>
<p><code>.text</code> 包含程序的子程序且坐落于 <code>FLASH</code> 的某些位置。它的开始地址没有指定，但是链接器将把它放在先前的输出section，<code>.vector_table</code> 之后。</p>
<p>输出 <code>.vector_table</code> section包含:</p>
<pre><code class="language-text">    /* First entry: initial Stack Pointer value */
    LONG(ORIGIN(RAM) + LENGTH(RAM));
</code></pre>
<p>我们将把(调用)栈放在RAM的末尾(栈是<em>完全递减的</em>；它向着更小的地址增长)因此RAM的末尾地址将被用作栈指针(SP)值。链接器使用我们输入的<code>RAM</code>存储区块的信息，可以算出那个地址。</p>
<pre><code>    /* Second entry: reset vector */
    KEEP(*(.vector_table.reset_vector));
</code></pre>
<p>接下来，我们使用 <code>KEEP</code> 去强迫链接器在初始的SP值之后插入所有的名为 <code>.vector_table.reset_vector</code> 的input sections 。位于那个section中的唯一一个符号是 <code>RESET_VECTOR</code>，所以这将可以把 <code>RESEET_VECTOR</code> 放在向量表的第二个位置。</p>
<p>输出的 <code>.text</code> section 包含:</p>
<pre><code class="language-text">    *(.text .text.*);
</code></pre>
<p>这包括所有的名为 <code>.text</code> 和 <code>.text.*</code> 的input sections 。注意我们这里没有使用 <code>KEEP</code> 去让链接器丢弃不使用的部分。</p>
<p>最后，我们使用特殊的 <code>/DISCARD/</code> section 去丢弃</p>
<pre><code class="language-text">    *(.ARM.exidx .ARM.exidx.*);
</code></pre>
<p>名为 <code>.ARM.exidx.*</code> 的input sections 。这些sections与异常处理有关，但是我们在恐慌时不进行栈展开，它们占用Flash的存储空间，因此我们就丢弃它们。</p>
<h2 id="全放到一起去"><a class="header" href="#全放到一起去">全放到一起去</a></h2>
<p>现在我们能链接应用了。作为参考，这里是完整的Rust程序:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_main]
#![no_std]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

// The reset handler
#[no_mangle]
pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {
    let _x = 42;

    // can't return so we go into an infinite loop here
    loop {}
}

// The reset vector, a pointer into the reset handler
#[link_section = &quot;.vector_table.reset_vector&quot;]
#[no_mangle]
pub static RESET_VECTOR: unsafe extern &quot;C&quot; fn() -&gt; ! = Reset;

#[panic_handler]
fn panic(_panic: &amp;PanicInfo&lt;'_&gt;) -&gt; ! {
    loop {}
}
<span class="boring">}</span></code></pre></pre>
<p>我们不得不修改链接的过程让它使用我们的链接器脚本。通过传递 <code>-C link-arg</code> 标志给 <code>rustc</code> 来完成它。使用 <code>cargo-rustc</code> 或者 <code>cargo-build</code> 就可以完成了。</p>
<p><strong>重要</strong>: 在运行这个命令之前确保你有 <code>.cargo/config</code> 文件，其在上个章节末尾处被添加了。</p>
<p>使用 <code>cargo-rustc</code> 子命令:</p>
<pre><code class="language-console">$ cargo rustc -- -C link-arg=-Tlink.x
</code></pre>
<p>或者你可以在 <code>.cargo/config</code> 中设置rustflags，并继续使用 <code>cargo-build</code> 子命令。我们将会使用后者因为它与<code>cargo-binutils</code>集成的更好。</p>
<pre><code class="language-console"># 将 .cargo/config 修改成这些内容
$ cat .cargo/config
</code></pre>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
rustflags = [&quot;-C&quot;, &quot;link-arg=-Tlink.x&quot;]

[build]
target = &quot;thumbv7m-none-eabi&quot;
</code></pre>
<p><code>[target.thumbv7m-none-eabi]</code> 部分告知这些标志只会被用于当交叉编译的目标是<code>thumbv7m-none-eabi</code>时。</p>
<h2 id="检查它"><a class="header" href="#检查它">检查它</a></h2>
<p>现在让我们检查下输出的二进制项，确保存储布局跟我们想要的一样
(这需要 <a href="https://github.com/rust-embedded/cargo-binutils#readme"><code>cargo-binutils</code></a>):</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -d --no-show-raw-insn
</code></pre>
<pre><code class="language-text">
app:	file format elf32-littlearm

Disassembly of section .text:

&lt;Reset&gt;:
               	sub	sp, #0x4
               	movs	r0, #0x2a
               	str	r0, [sp]
               	b	0x10 &lt;Reset+0x8&gt;        @ imm = #-0x2
               	b	0x10 &lt;Reset+0x8&gt;        @ imm = #-0x4
</code></pre>
<p>这是 <code>.text</code> section的反汇编。我们看到重置处理函数，名为 <code>Reset</code>，位于 <code>0x8</code> 地址。</p>
<pre><code class="language-console">$ cargo objdump --bin app -- -s --section .vector_table
</code></pre>
<pre><code class="language-text">
app:	file format elf32-littlearm
Contents of section .vector_table:
 0000 00000120 09000000                    ... ....
</code></pre>
<p>这是 <code>.vector_table</code> section 的内容。我们可以看到section开始于地址 <code>0x0</code> 且 section 的第一个字是 <code>0x2001_0000</code> (<code>objdump</code> 的输出是小端模式)。这是初始的SP值，它与RAM的末尾地址匹配。第二个字是 <code>0x9</code>；这是重置处理函数的 <em>thumb mode</em> 的地址。当一个函数运行在thumb mode下，它的地址的第一位被设置成1 。</p>
<h2 id="测试它"><a class="header" href="#测试它">测试它</a></h2>
<p>这个程序是一个有效的LM3S6965程序；我们可以在一个虚拟微控制器(QEMU)中执行它去测试。</p>
<pre><code class="language-console">$ # 这个程序将会阻塞住
$ qemu-system-arm \
      -cpu cortex-m3 \
      -machine lm3s6965evb \
      -gdb tcp::3333 \
      -S \
      -nographic \
      -kernel target/thumbv7m-none-eabi/debug/app
</code></pre>
<pre><code class="language-console">$ # 在一个不同的终端上
$ arm-none-eabi-gdb -q target/thumbv7m-none-eabi/debug/app
Reading symbols from target/thumbv7m-none-eabi/debug/app...done.

(gdb) target remote :3333
Remote debugging using :3333
Reset () at src/main.rs:8
8       pub unsafe extern &quot;C&quot; fn Reset() -&gt; ! {

(gdb) # the SP has the initial value we programmed in the vector table
(gdb) print/x $sp
$1 = 0x20010000

(gdb) step
9           let _x = 42;

(gdb) step
12          loop {}

(gdb) # next we inspect the stack variable `_x`
(gdb) print _x
$2 = 42

(gdb) print &amp;_x
$3 = (i32 *) 0x2000fffc

(gdb) quit
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="smallest-no-std.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="main.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="smallest-no-std.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="main.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
