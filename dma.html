<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DMA - The Embedonomicon</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="smallest-no-std.html"><strong aria-hidden="true">1.</strong> 最简的 #![no_std] 程序</a></li><li class="chapter-item expanded "><a href="memory-layout.html"><strong aria-hidden="true">2.</strong> 存储布局</a></li><li class="chapter-item expanded "><a href="main.html"><strong aria-hidden="true">3.</strong> 一个 main 接口</a></li><li class="chapter-item expanded "><a href="exceptions.html"><strong aria-hidden="true">4.</strong> 异常处理</a></li><li class="chapter-item expanded "><a href="asm.html"><strong aria-hidden="true">5.</strong> 稳定的汇编</a></li><li class="chapter-item expanded "><a href="logging.html"><strong aria-hidden="true">6.</strong> 使用符号做日志</a></li><li class="chapter-item expanded "><a href="singleton.html"><strong aria-hidden="true">7.</strong> 全局单例</a></li><li class="chapter-item expanded "><a href="dma.html" class="active"><strong aria-hidden="true">8.</strong> DMA</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="compiler-support.html">与编译器支持有关的笔记</a></li><li class="chapter-item expanded affix "><a href="custom-target.html">制造一个自定义目标</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Embedonomicon</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="直接存储器访问-dma"><a class="header" href="#直接存储器访问-dma">直接存储器访问 (DMA)</a></h1>
<p>本节会围绕DMA传输，讨论要搭建一个内存安全的API的核心需求。</p>
<p>DMA外设被用来以并行于处理器的工作(主程序的执行)的方式来执行存储传输。一个DMA传输或多或少等于启动一个进程(看<a href="https://doc.rust-lang.org/std/thread/fn.spawn.html"><code>thread::spawn</code></a>)去执行一个<code>memcpy</code> 。我们将用fork-join模型去解释一个内存安全的API的要求。</p>
<p>考虑下面的DMA数据类型：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A singleton that represents a single DMA channel (channel 1 in this case)
///
/// This singleton has exclusive access to the registers of the DMA channel 1
pub struct Dma1Channel1 {
    // ..
}

impl Dma1Channel1 {
    /// Data will be written to this `address`
    ///
    /// `inc` indicates whether the address will be incremented after every byte transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_destination_address(&amp;mut self, address: usize, inc: bool) {
        // ..
    }

    /// Data will be read from this `address`
    ///
    /// `inc` indicates whether the address will be incremented after every byte transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_source_address(&amp;mut self, address: usize, inc: bool) {
        // ..
    }

    /// Number of bytes to transfer
    ///
    /// NOTE this performs a volatile write
    pub fn set_transfer_length(&amp;mut self, len: usize) {
        // ..
    }

    /// Starts the DMA transfer
    ///
    /// NOTE this performs a volatile write
    pub fn start(&amp;mut self) {
        // ..
    }

    /// Stops the DMA transfer
    ///
    /// NOTE this performs a volatile write
    pub fn stop(&amp;mut self) {
        // ..
    }

    /// Returns `true` if there's a transfer in progress
    ///
    /// NOTE this performs a volatile read
    pub fn in_progress() -&gt; bool {
        // ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>假设<code>Dma1Channel1</code>被静态地配置成按one-shot的模式(也即不是circular模式)使用串口(又称作UART或者USART) #1，<code>Serial1</code>。
<code>Serial1</code>提供下面的<em>阻塞</em>版的API：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A singleton that represents serial port #1
pub struct Serial1 {
    // ..
}

impl Serial1 {
    /// Reads out a single byte
    ///
    /// NOTE: blocks if no byte is available to be read
    pub fn read(&amp;mut self) -&gt; Result&lt;u8, Error&gt; {
        // ..
    }

    /// Sends out a single byte
    ///
    /// NOTE: blocks if the output FIFO buffer is full
    pub fn write(&amp;mut self, byte: u8) -&gt; Result&lt;(), Error&gt; {
        // ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>假设我们想要将<code>Serial1</code> API扩展成可以(a)异步地发送一个缓存区和(b)异步地填充一个缓存区。</p>
<p>一开始我们将使用一个存储不安全的API，然后我们将迭代它直到它完全变成存储安全的API。在每一步，我们都将向你展示如何破开API，
让你意识到当使用异步的存储操作时，有哪些问题需要被解决。</p>
<h2 id="开场"><a class="header" href="#开场">开场</a></h2>
<p>作为开端，让我们尝试使用<a href="https://doc.rust-lang.org/std/io/trait.Write.html#method.write_all"><code>Write::write_all</code></a> API作为参考。为了简便，让我们忽略所有的错误处理。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A singleton that represents serial port #1
pub struct Serial1 {
    // NOTE: we extend this struct by adding the DMA channel singleton
    dma: Dma1Channel1,
    // ..
}

impl Serial1 {
    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;'a&gt;(mut self, buffer: &amp;'a [u8]) -&gt; Transfer&lt;&amp;'a [u8]&gt; {
        self.dma.set_destination_address(USART1_TX, false);
        self.dma.set_source_address(buffer.as_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        self.dma.start();

        Transfer { buffer }
    }
}

/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    buffer: B,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Returns `true` if the DMA transfer has finished
    pub fn is_done(&amp;self) -&gt; bool {
        !Dma1Channel1::in_progress()
    }

    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(self) -&gt; B {
        // Busy wait until the transfer is done
        while !self.is_done() {}

        self.buffer
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意：</strong> 不用像上面的API一样，<code>Transfer</code>的API也可以暴露一个futures或者generator。
这是一个API设计问题，与整个API的内存安全性关系不大，因此我们在本文中不会深入讨论。</p>
</blockquote>
<p>我们也可以实现一个异步版本的<a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_exact"><code>Read::read_exact</code></a> 。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;'a&gt;(&amp;mut self, buffer: &amp;'a mut [u8]) -&gt; Transfer&lt;&amp;'a mut [u8]&gt; {
        self.dma.set_source_address(USART1_RX, false);
        self.dma
            .set_destination_address(buffer.as_mut_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        self.dma.start();

        Transfer { buffer }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这里是<code>write_all</code> API的用法：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn write(serial: Serial1) {
    // fire and forget
    serial.write_all(b&quot;Hello, world!\n&quot;);

    // do other stuff
}
<span class="boring">}</span></code></pre></pre>
<p>这是使用<code>read_exact</code> API的一个例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read(mut serial: Serial1) {
    let mut buf = [0; 16];
    let t = serial.read_exact(&amp;mut buf);

    // do other stuff

    t.wait();

    match buf.split(|b| *b == b'\n').next() {
        Some(b&quot;some-command&quot;) =&gt; { /* do something */ }
        _ =&gt; { /* do something else */ }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="memforget"><a class="header" href="#memforget"><code>mem::forget</code></a></h2>
<p><a href="https://doc.rust-lang.org/std/mem/fn.forget.html"><code>mem::forget</code></a>是一个安全的API。如果我们的API真的是安全的，那么我们应该能够将两者结合使用而不会出现未定义的行为。然而，情况并非如此；考虑下下面的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unsound(mut serial: Serial1) {
    start(&amp;mut serial);
    bar();
}

#[inline(never)]
fn start(serial: &amp;mut Serial1) {
    let mut buf = [0; 16];

    // start a DMA transfer and forget the returned `Transfer` value
    mem::forget(serial.read_exact(&amp;mut buf));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
<span class="boring">}</span></code></pre></pre>
<p>在<code>start</code>中我们启动了一个DMA传输以填充一个在堆上分配的数组，然后<code>mem::forget</code>了被返回的<code>Transfer</code>值。然后我们继续从<code>start</code>返回并执行函数<code>bar</code> 。</p>
<p>这一系列操作导致了未定义的行为。DMA传输向栈的存储区写入，但是当<code>start</code>返回时，那块存储区域会被释放，
然后被<code>bar</code>重新用来分配像是<code>x</code>和<code>y</code>这样的变量。在运行时，这可能会导致变量<code>x</code>和<code>y</code>随机更改其值。DMA传输
也会覆盖掉被函数<code>bar</code>的序言推入栈中的状态(比如link寄存器)。</p>
<p>注意如果我们不用<code>mem::forget</code>，而是<code>mem::drop</code>，可以让<code>Transfer</code>的析构函数停止DMA的传输，这样程序就变成了安全的了。但是<em>不</em>能依赖于运行析构函数来加强存储安全性因为<code>mem::forget</code>和内存泄露(看下RC cycles)在Rust中是安全的。</p>
<p>通过在APIs中把缓存的生命周期从<code>'a</code>变成<code>'static</code>来修复这个问题。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact(&amp;mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        // .. same as before ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>如果我们尝试复现先前的问题，我们注意到<code>mem::forget</code>不再引起问题了。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
fn sound(mut serial: Serial1, buf: &amp;'static mut [u8; 16]) {
    // NOTE `buf` is moved into `foo`
    foo(&amp;mut serial, buf);
    bar();
}

#[inline(never)]
fn foo(serial: &amp;mut Serial1, buf: &amp;'static mut [u8]) {
    // start a DMA transfer and forget the returned `Transfer` value
    mem::forget(serial.read_exact(buf));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
<span class="boring">}</span></code></pre></pre>
<p>像之前一样，在<code>mem::forget</code> <code>Transfer</code>的值之后，DMA传输继续运行着。这次没有问题了，因为<code>buf</code>是静态分配的(比如<code>static mut</code>变量)，不是在栈上。</p>
<h2 id="重复使用overlapping-use"><a class="header" href="#重复使用overlapping-use">重复使用(Overlapping use)</a></h2>
<p>我们的API没有阻止用户在DMA传输过程中再次使用<code>Serial</code>接口。这可能导致传输失败或者数据丢失。</p>
<p>有许多方法可以禁止重叠使用。一个方法是让<code>Transfer</code>获取<code>Serial1</code>的所有权，然后当<code>wait</code>被调用时将它返回。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    buffer: B,
    // NOTE: added
    serial: Serial1,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    // NOTE: the return value has changed
    pub fn wait(self) -&gt; (B, Serial1) {
        // Busy wait until the transfer is done
        while !self.is_done() {}

        (self.buffer, self.serial)
    }

    // ..
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    // NOTE we now take `self` by value
    pub fn read_exact(mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        // .. same as before ..

        Transfer {
            buffer,
            // NOTE: added
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    // NOTE we now take `self` by value
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        // .. same as before ..

        Transfer {
            buffer,
            // NOTE: added
            serial: self,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>移动语义静态地阻止了当传输在进行时对<code>Serial1</code>的访问。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read(serial: Serial1, buf: &amp;'static mut [u8; 16]) {
    let t = serial.read_exact(buf);

    // let byte = serial.read(); //~ ERROR: `serial` has been moved

    // .. do stuff ..

    let (serial, buf) = t.wait();

    // .. do more stuff ..
}
<span class="boring">}</span></code></pre></pre>
<p>还有其它方法可以防止重叠使用。比如，可以往<code>Serial1</code>添加一个(<code>Cell</code>)标志，其指出是否一个DMA传输正在进行中。
当标志被设置了，<code>read</code>，<code>write</code>，<code>read_exact</code>和<code>write_all</code>全都会在运行时返回一个错误(比如<code>Error::InUse</code>)。
当使用<code>write_all</code> / <code>read_exact</code>时，会设置标志，在<code>Transfer.wait</code>中，标志会被清除。</p>
<h2 id="编译器误优化"><a class="header" href="#编译器误优化">编译器(误)优化</a></h2>
<p>编译器可以自由地重新排序和合并不是volatile的存储操作以更好地优化一个程序。使用我们现在的API，这种自由度会导致未定义的行为。想一下下面的例子：</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reorder(serial: Serial1, buf: &amp;'static mut [u8]) {
    // zero the buffer (for no particular reason)
    buf.iter_mut().for_each(|byte| *byte = 0);

    let t = serial.read_exact(buf);

    // ... do other stuff ..

    let (buf, serial) = t.wait();

    buf.reverse();

    // .. do stuff with `buf` ..
}
<span class="boring">}</span></code></pre></pre>
<p>这里编译器可以将<code>buf.reverse()</code>移到<code>t.wait()</code>之前，其将导致一个数据竞争问题：处理器和DMA最终都会同时修改<code>buf</code> 。同样地编译器可以将赋零操作放到<code>read_exact</code>之后，它也会导致一个数据竞争问题。</p>
<p>为了避免这些存在问题的重排序，我们可以使用一个 <a href="https://doc.rust-lang.org/core/sync/atomic/fn.compiler_fence.html"><code>compiler_fence</code></a></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact(mut self, buffer: &amp;'static mut [u8]) -&gt; Transfer&lt;&amp;'static mut [u8]&gt; {
        self.dma.set_source_address(USART1_RX, false);
        self.dma
            .set_destination_address(buffer.as_mut_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        // NOTE: added
        atomic::compiler_fence(Ordering::Release);

        // NOTE: this is a volatile *write*
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all(mut self, buffer: &amp;'static [u8]) -&gt; Transfer&lt;&amp;'static [u8]&gt; {
        self.dma.set_destination_address(USART1_TX, false);
        self.dma.set_source_address(buffer.as_ptr() as usize, true);
        self.dma.set_transfer_length(buffer.len());

        // NOTE: added
        atomic::compiler_fence(Ordering::Release);

        // NOTE: this is a volatile *write*
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(self) -&gt; (B, Serial1) {
        // NOTE: this is a volatile *read*
        while !self.is_done() {}

        // NOTE: added
        atomic::compiler_fence(Ordering::Acquire);

        (self.buffer, self.serial)
    }

    // ..
}
<span class="boring">}</span></code></pre></pre>
<p>我们在<code>read_exact</code>和<code>write_all</code>中使用<code>Ordering::Release</code>以避免所有的正在进行中的存储操作被移动到<code>self.dma.start()</code>后面去，其执行了一个volatile写入。</p>
<p>同样地，我们在<code>Transfer.wait</code>中使用<code>Ordering::Acquire</code>以避免所有的后续的存储操作被移到<code>self.is_done()</code><em>之前</em>，其执行了一个volatile读入。</p>
<p>为了更好地展示fences的影响，稍微修改下上个部分中的例子。我们将fences和它们的orderings添加到注释中。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reorder(serial: Serial1, buf: &amp;'static mut [u8], x: &amp;mut u32) {
    // zero the buffer (for no particular reason)
    buf.iter_mut().for_each(|byte| *byte = 0);

    *x += 1;

    let t = serial.read_exact(buf); // compiler_fence(Ordering::Release) ▲

    // NOTE: the processor can't access `buf` between the fences
    // ... do other stuff ..
    *x += 2;

    let (buf, serial) = t.wait(); // compiler_fence(Ordering::Acquire) ▼

    *x += 3;

    buf.reverse();

    // .. do stuff with `buf` ..
}
<span class="boring">}</span></code></pre></pre>
<p>由于<code>Release</code> fence，赋零操作<em>不</em>能被移到<code>read_exact</code><em>之后</em>。同样地，由于<code>Acquire</code> fence，<code>reverse</code>操作<em>不</em>能被移动<code>wait</code>之前。
在两个fences<em>之间</em>的存储操作<em>可以</em>在fences间自由地重新排序，但是这些操作都不会涉及到<code>buf</code>，所以这种重新排序<em>不</em>会导致未定义的行为。</p>
<p>请注意<code>compiler_fence</code>比要求的强一些。比如，fences将防止在<code>x</code>上的操作被合并即使我们知道<code>buf</code>不会与<code>x</code>重叠(由于Rust的别名规则)。
然而，没有比<code>compiler_fence</code>更精细的内部函数了。</p>
<h3 id="我们需不需要内存屏障"><a class="header" href="#我们需不需要内存屏障">我们需不需要内存屏障？</a></h3>
<p>这取决于目标平台的架构。在Cortex M0到M4F核心的例子里，<a href="https://static.docs.arm.com/dai0321/a/DAI0321A_programming_guide_memory_barriers_for_m_profile.pdf">AN321</a>说到：</p>
<blockquote>
<p>3.2 主要场景</p>
<p>(..)</p>
<p>在Cortex-M处理器中，很少需要用到DMB因为它们不会重新排序存储传输。
然而，如果软件要在其它ARM处理器中复用，那么就需要用到，特别是多主机系统。比如：</p>
<ul>
<li>DMA控制器配置。在CPU存储访问和一个DMA操作间需要一个屏障。</li>
</ul>
<p>(..)</p>
<p>4.18 多主机系统</p>
<p>(..)</p>
<p>把47页图41和图42的例子中的DMB或者DSB指令去除掉不会导致任何错误，因为Cortex-M处理器：</p>
<ul>
<li>不会重新排序存储传输。</li>
<li>不会允许两个写传输重叠。</li>
</ul>
</blockquote>
<p>这里图41中展示了在启动DMA传输前使用了一个DMB（存储屏障）指令。</p>
<p>在Cortex-M7内核的例子中，如果你使用了数据缓存（DCache），那么你需要存储屏障（DMB/DSB），除非你手动地无效化被DMA使用的缓存。即使将数据缓存取消掉，可能依然需要内存屏障以避免存储缓存中出现重新排序。</p>
<p>如果你的目标平台是一个多核系统，那么很可能你需要内存屏障。</p>
<p>如果你需要内存屏障，那么你需要使用<a href="https://doc.rust-lang.org/core/sync/atomic/fn.fence.html"><code>atomic::fence</code></a>而不是<code>compiler_fence</code>。这在Cortex-M设备上会生成一个DMB指令。</p>
<h2 id="泛化缓存"><a class="header" href="#泛化缓存">泛化缓存</a></h2>
<p>我们的API太受限了。比如，下面的程序即使是有效的也不会被通过。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reuse(serial: Serial1, msg: &amp;'static mut [u8]) {
    // send a message
    let t1 = serial.write_all(msg);

    // ..

    let (msg, serial) = t1.wait(); // `msg` is now `&amp;'static [u8]`

    msg.reverse();

    // now send it in reverse
    let t2 = serial.write_all(msg);

    // ..

    let (buf, serial) = t2.wait();

    // ..
}
<span class="boring">}</span></code></pre></pre>
<p>为了能接受这样的程序，我们可以让缓存参数更泛化点。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// as-slice = &quot;0.1.0&quot;
use as_slice::{AsMutSlice, AsSlice};

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: B) -&gt; Transfer&lt;B&gt;
    where
        B: AsMutSlice&lt;Element = u8&gt;,
    {
        // NOTE: added
        let slice = buffer.as_mut_slice();
        let (ptr, len) = (slice.as_mut_ptr(), slice.len());

        self.dma.set_source_address(USART1_RX, false);

        // NOTE: tweaked
        self.dma.set_destination_address(ptr as usize, true);
        self.dma.set_transfer_length(len);

        atomic::compiler_fence(Ordering::Release);
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    fn write_all&lt;B&gt;(mut self, buffer: B) -&gt; Transfer&lt;B&gt;
    where
        B: AsSlice&lt;Element = u8&gt;,
    {
        // NOTE: added
        let slice = buffer.as_slice();
        let (ptr, len) = (slice.as_ptr(), slice.len());

        self.dma.set_destination_address(USART1_TX, false);

        // NOTE: tweaked
        self.dma.set_source_address(ptr as usize, true);
        self.dma.set_transfer_length(len);

        atomic::compiler_fence(Ordering::Release);
        self.dma.start();

        Transfer {
            buffer,
            serial: self,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意:</strong> 可以使用 <code>AsRef&lt;[u8]&gt;</code> (<code>AsMut&lt;[u8]&gt;</code>) 而不是
<code>AsSlice&lt;Element = u8&gt;</code> (<code>AsMutSlice&lt;Element = u8</code>).</p>
</blockquote>
<p>现在 <code>reuse</code> 程序可以通过了。</p>
<h2 id="不可移动的缓存"><a class="header" href="#不可移动的缓存">不可移动的缓存</a></h2>
<p>这么修改后，API也可以通过值传递接受数组。（比如 <code>[u8; 16]</code>）。然后，使用数组会导致指针无效化。考虑下面的程序。</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn invalidate(serial: Serial1) {
    let t = start(serial);

    bar();

    let (buf, serial) = t.wait();
}

#[inline(never)]
fn start(serial: Serial1) -&gt; Transfer&lt;[u8; 16]&gt; {
    // array allocated in this frame
    let buffer = [0; 16];

    serial.read_exact(buffer)
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
<span class="boring">}</span></code></pre></pre>
<p><code>read_exact</code> 操作将使用位于 <code>start</code> 函数的 <code>buffer</code> 的地址。当 <code>start</code> 返回时，局部的 <code>buffer</code> 将会被释放，在 <code>read_exact</code> 中使用的指针将会变得无效化。你最后会遇到与 <a href="#dealing-with-memforget"><code>unsound</code></a> 案例中一样的情况。</p>
<p>为了避免这个问题，我们要求我们的API使用的缓存即使当它被移动时依然保有它的内存区域。<a href="https://doc.rust-lang.org/nightly/std/pin/index.html"><code>Pin</code></a> 类型提供这样的保障。首先我们可以更新我们的API以要求所有的缓存都是 &quot;pinned&quot; 的。</p>
<blockquote>
<p><strong>注意：</strong> 要编译下面的所有程序，你的Rust需要 
<code>&gt;=1.33.0</code>。写这本书的时候 (2019-01-04) 这意味着要使用 nightly
版的Rust</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    // NOTE: changed
    buffer: Pin&lt;B&gt;,
    serial: Serial1,
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: bounds changed
        B: DerefMut,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: bounds changed
        B: Deref,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>注意：</strong> 我们可以使用 <a href="https://crates.io/crates/stable_deref_trait"><code>StableDeref</code></a> 特质而不是 <code>Pin</code>
newtype but opted for <code>Pin</code> since it's provided in the standard library.</p>
</blockquote>
<p>With this new API we can use <code>&amp;'static mut</code> references, <code>Box</code>-ed slices, <code>Rc</code>-ed
slices, etc.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn static_mut(serial: Serial1, buf: &amp;'static mut [u8]) {
    let buf = Pin::new(buf);

    let t = serial.read_exact(buf);

    // ..

    let (buf, serial) = t.wait();

    // ..
}

fn boxed(serial: Serial1, buf: Box&lt;[u8]&gt;) {
    let buf = Pin::new(buf);

    let t = serial.read_exact(buf);

    // ..

    let (buf, serial) = t.wait();

    // ..
}
<span class="boring">}</span></code></pre></pre>
<h2 id="static-bound"><a class="header" href="#static-bound"><code>'static</code> bound</a></h2>
<p>Does pinning let us safely use stack allocated arrays? The answer is <em>no</em>.
Consider the following example.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn unsound(serial: Serial1) {
    start(serial);

    bar();
}

// pin-utils = &quot;0.1.0-alpha.4&quot;
use pin_utils::pin_mut;

#[inline(never)]
fn start(serial: Serial1) {
    let buffer = [0; 16];

    // pin the `buffer` to this stack frame
    // `buffer` now has type `Pin&lt;&amp;mut [u8; 16]&gt;`
    pin_mut!(buffer);

    mem::forget(serial.read_exact(buffer));
}

#[inline(never)]
fn bar() {
    // stack variables
    let mut x = 0;
    let mut y = 0;

    // use `x` and `y`
}
<span class="boring">}</span></code></pre></pre>
<p>As seen many times before, the above program runs into undefined behavior due to
stack frame corruption.</p>
<p>The API is unsound for buffers of type <code>Pin&lt;&amp;'a mut [u8]&gt;</code> where <code>'a</code> is <em>not</em>
<code>'static</code>. To prevent the problem we have to add a <code>'static</code> bound in some
places.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: added 'static bound
        B: DerefMut + 'static,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        // NOTE: added 'static bound
        B: Deref + 'static,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..
    }
}
<span class="boring">}</span></code></pre></pre>
<p>现在有问题的程序将被拒绝。</p>
<h2 id="析构函数"><a class="header" href="#析构函数">析构函数</a></h2>
<p>Now that the API accepts <code>Box</code>-es and other types that have destructors we need
to decide what to do when <code>Transfer</code> is early-dropped.</p>
<p>Normally, <code>Transfer</code> values are consumed using the <code>wait</code> method but it's also
possible to, implicitly or explicitly, <code>drop</code> the value before the transfer is
over. For example, dropping a <code>Transfer&lt;Box&lt;[u8]&gt;&gt;</code> value will cause the buffer
to be deallocated. This can result in undefined behavior if the transfer is
still in progress as the DMA would end up writing to deallocated memory.</p>
<p>In such scenario one option is to make <code>Transfer.drop</code> stop the DMA transfer.
The other option is to make <code>Transfer.drop</code> wait for the transfer to finish.
We'll pick the former option as it's cheaper.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A DMA transfer
pub struct Transfer&lt;B&gt; {
    // NOTE: always `Some` variant
    inner: Option&lt;Inner&lt;B&gt;&gt;,
}

// NOTE: previously named `Transfer&lt;B&gt;`
struct Inner&lt;B&gt; {
    buffer: Pin&lt;B&gt;,
    serial: Serial1,
}

impl&lt;B&gt; Transfer&lt;B&gt; {
    /// Blocks until the transfer is done and returns the buffer
    pub fn wait(mut self) -&gt; (Pin&lt;B&gt;, Serial1) {
        while !self.is_done() {}

        atomic::compiler_fence(Ordering::Acquire);

        let inner = self
            .inner
            .take()
            .unwrap_or_else(|| unsafe { hint::unreachable_unchecked() });
        (inner.buffer, inner.serial)
    }
}

impl&lt;B&gt; Drop for Transfer&lt;B&gt; {
    fn drop(&amp;mut self) {
        if let Some(inner) = self.inner.as_mut() {
            // NOTE: this is a volatile write
            inner.serial.dma.stop();

            // we need a read here to make the Acquire fence effective
            // we do *not* need this if `dma.stop` does a RMW operation
            unsafe {
                ptr::read_volatile(&amp;0);
            }

            // we need a fence here for the same reason we need one in `Transfer.wait`
            atomic::compiler_fence(Ordering::Acquire);
        }
    }
}

impl Serial1 {
    /// Receives data into the given `buffer` until it's filled
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn read_exact&lt;B&gt;(mut self, mut buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        B: DerefMut + 'static,
        B::Target: AsMutSlice&lt;Element = u8&gt; + Unpin,
    {
        // .. same as before ..

        Transfer {
            inner: Some(Inner {
                buffer,
                serial: self,
            }),
        }
    }

    /// Sends out the given `buffer`
    ///
    /// Returns a value that represents the in-progress DMA transfer
    pub fn write_all&lt;B&gt;(mut self, buffer: Pin&lt;B&gt;) -&gt; Transfer&lt;B&gt;
    where
        B: Deref + 'static,
        B::Target: AsSlice&lt;Element = u8&gt;,
    {
        // .. same as before ..

        Transfer {
            inner: Some(Inner {
                buffer,
                serial: self,
            }),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now the DMA transfer will be stopped before the buffer is deallocated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reuse(serial: Serial1) {
    let buf = Pin::new(Box::new([0; 16]));

    let t = serial.read_exact(buf); // compiler_fence(Ordering::Release) ▲

    // ..

    // this stops the DMA transfer and frees memory
    mem::drop(t); // compiler_fence(Ordering::Acquire) ▼

    // this likely reuses the previous memory allocation
    let mut buf = Box::new([0; 16]);

    // .. do stuff with `buf` ..
}
<span class="boring">}</span></code></pre></pre>
<h2 id="总结"><a class="header" href="#总结">总结</a></h2>
<p>To sum it up, we need to consider all the following points to achieve  memory
safe DMA transfers:</p>
<ul>
<li>
<p>Use immovable buffers plus indirection: <code>Pin&lt;B&gt;</code>. Alternatively, you can use
the <code>StableDeref</code> trait.</p>
</li>
<li>
<p>The ownership of the buffer must be passed to the DMA : <code>B: 'static</code>.</p>
</li>
<li>
<p>Do <em>not</em> rely on destructors running for memory safety. Consider what happens
if <code>mem::forget</code> is used with your API.</p>
</li>
<li>
<p><em>Do</em> add a custom destructor that stops the DMA transfer, or waits for it to
finish. Consider what happens if <code>mem::drop</code> is used with your API.</p>
</li>
</ul>
<hr />
<p>This text leaves out up several details required to build a production grade
DMA abstraction, like configuring the DMA channels (e.g. streams, circular vs
one-shot mode, etc.), alignment of buffers, error handling, how to make the
abstraction device-agnostic, etc. All those aspects are left as an exercise for
the reader / community (<code>:P</code>).
Overlapping use</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="singleton.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="compiler-support.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="singleton.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="compiler-support.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
